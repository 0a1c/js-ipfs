
package messages;

// A self-identifying payload frame.
// It includes a type to identify its payload packet.
// This is how encapsulation is done.
// This frame isn't included directly into the others
// (instead, we use `bytes`), because we need to be
// able to run operations on the encoded buffers
// (checksum, decrypt, encrypt, sign, etc).
message PayloadFrame {
  enum PayloadType {
    NetworkFrame = 1;
    IntegrityFrame = 2;
    DataMessage = 3;
  }

  optional PayloadType type = 1;
  optional bytes payload = 2;
}

// Routable IPFS Network Packet.
// From a source ID to a destination ID.
// IDs here are node identities, or groups.
message NetworkFrame {
  optional bytes source = 1;
  optional bytes destination = 2;
  optional bytes payload = 3; // a PayloadFrame
}

// A packet of data that is integrity-checked.
// Meaning, it includes a checksum (multihash).
message IntegrityFrame {
  optional Multihash checksum = 1;
  optional bytes payload = 2; // a PayloadFrame
}

// A DataMessage is a raw data buffer payload.
// this is more of an edge case for testing
// than a useful IPFS message.
message DataMessage {
  optional bytes payload = 1;
}

// Multihash embedded here from ipfs.crypto.
message Multihash {
  required bytes hash = 1;
}
